---
layout: default
title: Redis面试
---

<h2>{{ page.title }}</h2>

<b>为什么要使用Redis</b>
<ul>
    <li>高性能：Redis的数据是直接存储在内存中的，操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可。</li>
    <li>高并发：直接操作Redis能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</li>
    <li>Map等本地缓存，随着jvm的销毁而结束，多实例的情况下不具备一致性，故而使用Redis这种分布式缓存。</li>
</ul>

<b>Redis和Memcached的区别</b>
<ul>
    <li>Redis支持更多的数据类型(String,List,Set,ZSet,Hash)，而Memcached只支持String。</li>
    <li>Redis支持数据持久化，可以将数据保存在磁盘中，宕机恢复时方便恢复数据，Memcached数据只能存在内存中。</li>
    <li>Redis原生就支持集群，Memcached需要依靠客户端来实现往集群中分片写入数据。</li>
    <li>Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路IO复用模型</li>
    <li>Memcached将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。</li>
</ul>

<b>Redis数据类型和应用场景</b>
<ul>
    <li>String:存储值为字符串，整数，浮点数等。可对整个字符串或者字符串的其中一部分执行操作，对整数和浮点数执行自增或者自减操作。存储token等。</li>
    <li>List:存储值为双向列表。可从两端压入或者弹出元素，对单个或者多个元素进行修剪，只保留一个范围内的元素。最新消息排行等功能(比如朋友圈的时间线)，消息队列，聊天消息。</li>
    <li>Set:是string类型的无序集合。集合是通过hashtable实现的，概念和数学中个的集合基本类似，可以交集，并集，差集等等，set中的元素是没有顺序的。所以添加，删除，查找的复杂度都是O(1)。可应用查找共同好友，好友推荐等功能。</li>
    <li>ZSet:将Set中的元素增加一个权重参数score,元素按score有序排列。可使用其进行排行榜等统计排序，消息队列权重等。</li>
    <li>Hash:是一个键值(key => value)对集合。可当作关系型数据库表使用。</li>
</ul>

<b>内存淘汰机制</b>
<ul>
    <li>volatile-lru:从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。</li>
    <li>volatile-ttl:从已设置过期时间的数据集中挑选将要过期的进行淘汰。</li>
    <li>volatile-random:从已设置过期时间的数据集中随机挑选进行淘汰。</li>
    <li>allkeys-lru:当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。</li>
    <li>allkeys-radom:当内存不足以容纳新写入数据时，从数据集中任意淘汰。</li>
    <li>no-evicition:禁止驱逐数据。内存不足时写入会报错。</li>
    新加入的有：
    <li>volatile-lfu:从已设置过期时间的数据集中挑选最不经常使用的数据淘汰。</li>
    <li>allkeys-lfu:当内存不足以容纳新写入数据时，在键空间中，移除最近最不常用的key。</li>
</ul>

<b>持久化机制</b>
<ul>
    <li>快照：Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性能），还可以将快照留在原地以便重启服务器的时候使用。</li>
    <li>追加文件（AOF）：有三种方式每次数据修改、每秒、让操作系统决定。建议使用每秒。</li>
</ul>

<b>Redis事务</b>
<p>通过 MULTI、EXEC、WATCH 等命令来实现事务(transaction)功能,在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。</p>
<p>在 Redis 中，事务总是具有原子性（Atomicity）、一致性（Consistency）和隔离性（Isolation），并且当 Redis 运行在某种特定的持久化模式下时，事务也具有持久性（Durability）。Redis原子性没有回滚故而不保证原子性。</p>

<b>雪崩以及解决方法</b>
<ul>
    <li>雪崩：缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</li>
    <li>事前：保证集群高可用，宕机时尽快补上。</li>
    <li>事中：本地进行缓存和服务降级，避免Mysql崩溃。</li>
    <li>事后：利用持久化机制尽快恢复。</li>
</ul>

<b>缓存击穿以及解决方法</b>
<ul>
    <li>缓存击穿：大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。</li>
    <li>缓存无效key：如果缓存和数据库都查不到某个 key 的数据就写一个到 redis 中去并设置过期时间（过期时间要短）缺点很明显大量无效key。</li>
    <li>使用布隆过滤器：布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在与海量数据中。把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，我会先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端。</li>
    <img src="https://camo.githubusercontent.com/e7b3bd189b985bebae82dbd2adce82f38208aaaf/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312fe5b883e99a86e8bf87e6bba4e599a82de7bc93e5ad98e7a9bfe9808f2d72656469732e706e67" />
</ul>

<b>并发竞争Key解决</b>
<ul>
    <li>使用分布式锁（zookeeper和redis都可实现）。</li>
    <li>首推zookeeper：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</li>
    <li>redis实现：可以使用Redis自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的RedLock分布式锁实现</li>
</ul>
<p>{{ page.date | date_to_string }}</p>