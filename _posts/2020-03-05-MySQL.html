---
layout: default
title: MySQL面试
---
<h2>{{ page.title }}</h2>
<h4>1.事务</h4><br>
<b>事务与其特性</b>
<p>事务是逻辑上的一组操作，要么都执行，要么都不执行。四大特性ACID。</p>
<ul>
    <li>原子性（Atomicity）： 事务是最执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
    <li>一致性（Consistency）： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
    <li>隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
    <li>持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ul>
<b>并发事务造成的问题</b>
<ul>
    <li>脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>
    <li>丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</li>
    <li>不可重复读（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。(主要是修改)</li>
    <li>幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。(主要为添加或者删除)</li>
</ul>
<b>MySQL事务隔离级别分为四种：READ-UNCOMMITTED(未提交读)、	READ-COMMITTED(提交读)、REPEATABLE-READ(可重复读)、SERIALIZABLE(可串行化)。</b>
<ul>
    <li>READ-UNCOMMITTED: 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
    <li>READ-COMMITTED: 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
    <li>REPEATABLE-READ: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。InnoDB的默认级别。 </li>
    <li>SERIALIZABLE: 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
</ul>
<h4>2.索引</h4>
<b>索引类型</b>
<p>MySQL的索引类型分为B-Tree索引、哈希索引、空间数据索引、全文索引、和其他索引。</p>
<ul>
    <li>B-Tree索引：B-Tree索引从技术上来说使用的B+Tree 人们说的索引默认为B-Tree索引。可以使用的类型：全值匹配（对索引中的列进行匹配）、匹配最左前缀（同上最左前缀）、匹配列前缀（匹配某一列的开头部分）、匹配范围值（索引第一列范围内）、精确匹配某一列并范围匹配到另一列（不多说）、只访问索引的查询（又名覆盖索引即只访问索引行）。
        限制：如果不是按照索引的最左列开始查找则无法使用索引、不能跳过索引中的列、查询中有某个列的范围值，其右边所有列都无法使用索引。（优化SQL语句时可以通过这几点来优化使用索引）
    </li>
    <li>哈希索引：基于哈希表实现，只有精确匹配索引所有列的查询才有效，只有Memory引擎支持（同时支持B-Tree索引），支持非唯一哈希索引。限制：只包含哈希值和指针不包含存储字段、无法用于排序（数据不按照索引值顺序存储）、不支持部分索引列匹配查找、只支持等值比较查询（= IN() <=>）、出现哈希冲突必须遍历所有行指针、哈希冲突过多维护代价高。</li>
    <li>空间数据索引：MyISAM引擎支持，可用作地理数据存储，无需前缀索引，必须使用mysql的GIS相关函数进行维护。（mysql支持的不完善一般nosql用）</li>
    <li>全文索引：查找文本关键字而不是直接比较索引中的值，与同列上和B-Tree索引不冲突 适用于MATH AGAINST操作。</li>
    <li>其他索引：第三方存储引擎使用如分行树索引。</li>
</ul>
<b>B-Tree索引分类</b>
<ul>
    <li>普通索引：最基本的索引，它没有任何限制，加快查询。</li>
    <li>唯一索引：在普通索引的基础上增加了唯一性索，但允许有空值。</li>
    <li>聚簇索引（InnonDB主键）：也称为一级索引（单表中只有一个存储了完整的数据），二级索引存储的是主键值（每次查找数据时，根据索引找到叶子节点中的主键值，根据主键值再到聚簇索引中得到完整的一行记录）。</li>
    <li>组合索引：两个或更多个列上的索引被称作复合索引。</li>
</ul>
<b>不能使用索引和索引失效</b>
<ul>
    <li>使用%模糊匹配时前置%会导致不能使用索引</li>
    <li>索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描。</li>
    <li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引。（会自动类型转换）</li>
    <li>如果mysql估计使用全表扫描要比使用索引快,则不使用索引。</li>
    <li>使用组合索引时没有匹配最左前缀法则</li>
    <li>条件中索引使用大于小于等这样子的范围值,其之后连接条件的索引会失效。</li>
    <li>or大多数情况下很少能利用到索引(条件全命中索引才行)</li>
    <li>对列进行函数转换或计算时会导致无法使用索引</li>
    <li>where条件中判断NULL，会转向全表扫描因为全表扫描更快。</li>
</ul>
<h4>3.数据库优化</h4>
<b>方案</b>
<ul>
	<li>优化现有的MySQL数据库。</li>
	<li>硬件优化，加钱买更好的服务器。</li>
	<li>使用NoSQL/NewSQL等。</li>
</ul>
<b>表优化</b>
<ul>
	<li>字段优先级： 整型 > date,time > emum char > varchar > blob,text</li>
	<li>尽量让字段不为空，空值会额外占用索引空间。</li>
	<li>尽量使用无符号INT而非BIGINT,如果更小的SMALLINT等够用的情况下使用其更好。</li>
	<li>保存时间时尽量使用TIMESTAMP，其次DATETIME，尽量不要使用VARCHAR。</li>
	<li>单表字段不宜过多，20以内为好。</li>
	<li>IP地址等字段尽量使用整形存储。</li>
	<li>精确值，例如金额等使用DECIMAL。</li>
	<li>VARCHAR的长度只分配真正需要的空间。</li>
	<li>可以使用enum代替varchar来保存字符串</li>
	<li>尽量不用TEXT，使用的情况进行分表操作。</li>
</ul>
<b>索引优化</b>
<ul>
	<li>必须要有主键，主键尽量为整型。InnoDB的聚簇索引为主键索引。</li>
	<li>数据值类别少的地方不建议索引，例如男女等。</li>
	<li>去掉不必要的索引，例如组合索引的前提下，又建立了满足最左前缀的索引、并没有使用到的索引等。</li>
	<li>在经常被使用到的字段加索引。WHERE或ORDER BY涉及到的列。</li>
	<li>建立索引的字段越小越好，尽量不为NULL。</li>
</ul>
<b>sql语句优化</b>
<ul>
    <li>尽量使用limit来限限制查询的数量。</li>
    <li>使用连接来代替来代替子查询</li>
    <li>优化语句防止索引失效，上边有。</li>
    <li>在进行条件判断时，应该保证条件前后类型相同。</li>
    <li>尽量再一次查询中获得想要的数据，避免在后台代码中二次判断。</li>
    <li>在明确保证两个表数据不同的情况下使用UNION ALL。</li>
    <li>不建议使用SELECT * (虽然优化了)。</li>
</ul>
<p>{{ page.date | date_to_string }}</p>