---
layout: default
title: MySQL面试
---
<h2>{{ page.title }}</h2>
<h4>1.事务</h4><br>
<b>事务与其特性</b>
<p>事务是逻辑上的一组操作，要么都执行，要么都不执行。四大特性ACID。</p>
<ul>
    <li>原子性（Atomicity）： 事务是最执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
    <li>一致性（Consistency）： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
    <li>隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
    <li>持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ul>
<b>并发事务造成的问题</b>
<ul>
    <li>脏读（Dirty read）:
        当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
    </li>
    <li>丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。
    </li>
    <li>不可重复读（Unrepeatableread）:
        指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。(主要是修改)
    </li>
    <li>幻读（Phantom read）:
        幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。(主要为添加或者删除)
    </li>
</ul>
<b>MySQL事务隔离级别分为四种：READ-UNCOMMITTED(未提交读)、 READ-COMMITTED(提交读)、REPEATABLE-READ(可重复读)、SERIALIZABLE(可串行化)。</b>
<ul>
    <li>READ-UNCOMMITTED: 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
    <li>READ-COMMITTED: 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
    <li>REPEATABLE-READ: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。InnoDB的默认级别。 </li>
    <li>SERIALIZABLE: 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
</ul>
<b>MVCC</b>
<ul>
    <li>MVCC多版本并发控制，主要适用于MySQL提交读（RC）和可重复读（RR）隔离级别。通过保存数据在某个时间点的快照来实现。（乐观锁）</li>
    <li>特征：1.每行数据都存在一个版本，每次数据更新时都更新该版本。2.修改时Copy出当前版本随意修改，各个事务之间无干扰。（类似于CopyOnWrite）3.保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）
    </li>
    <li>InnoDB中的实现策略：在每一行数据中额外保存两个隐藏的列：当前行创建时的版本号（create_version）和删除时的版本号（delete_version）。（可为空）每开始新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询每行记录的版本号进行比较。
        每个事务又有自己的版本号，这样事务内执行CRUD操作时，就通过版本号的比较来达到数据版本控制的目的。</li>
    <li>MVCC模式下InnoDB工作流程：1.插入数据（insert）:记录的版本号即当前事务的版本号（create_version）2.更新操作的时候，采用的是先标记旧的那行记录为已删除(标记delete_version)，并且删除版本号是事务版本号，然后插入一行新的记录的方式。
        3.删除操作的时候，就把事务版本号作为删除版本号。4.查询时要符合以下两个条件的记录才能被事务查询出来：1)删除版本号未指定或者大于当前事务版本号 2)创建版本号 小于或者等于 当前事务版本号
    </li>
</ul>
<h4>2.索引</h4>
<b>索引类型</b>
<p>MySQL的索引类型分为B-Tree索引、哈希索引、空间数据索引、全文索引、和其他索引。</p>
<ul>
    <li>B-Tree索引：B-Tree索引从技术上来说使用的B+Tree
        人们说的索引默认为B-Tree索引。可以使用的类型：全值匹配（对索引中的列进行匹配）、匹配最左前缀（同上最左前缀）、匹配列前缀（匹配某一列的开头部分）、匹配范围值（索引第一列范围内）、精确匹配某一列并范围匹配到另一列（不多说）、只访问索引的查询（又名覆盖索引即只访问索引行）。
        限制：如果不是按照索引的最左列开始查找则无法使用索引、不能跳过索引中的列、查询中有某个列的范围值，其右边所有列都无法使用索引。（优化SQL语句时可以通过这几点来优化使用索引）
    </li>
    <li>哈希索引：基于哈希表实现，只有精确匹配索引所有列的查询才有效，只有Memory引擎支持（同时支持B-Tree索引），支持非唯一哈希索引。限制：只包含哈希值和指针不包含存储字段、无法用于排序（数据不按照索引值顺序存储）、不支持部分索引列匹配查找、只支持等值比较查询（=
        IN() <=>）、出现哈希冲突必须遍历所有行指针、哈希冲突过多维护代价高。</li>
    <li>空间数据索引：MyISAM引擎支持，可用作地理数据存储，无需前缀索引，必须使用mysql的GIS相关函数进行维护。（mysql支持的不完善一般nosql用）</li>
    <li>全文索引：查找文本关键字而不是直接比较索引中的值，与同列上和B-Tree索引不冲突 适用于MATH AGAINST操作。</li>
    <li>其他索引：第三方存储引擎使用如分行树索引。</li>
</ul>
<b>B-Tree索引分类</b>
<ul>
    <li>普通索引：最基本的索引，它没有任何限制，加快查询。</li>
    <li>唯一索引：在普通索引的基础上增加了唯一性索，但允许有空值。</li>
    <li>聚簇索引（InnonDB主键）：也称为一级索引（单表中只有一个存储了完整的数据），二级索引存储的是主键值（每次查找数据时，根据索引找到叶子节点中的主键值，根据主键值再到聚簇索引中得到完整的一行记录）。</li>
    <li>组合索引：两个或更多个列上的索引被称作复合索引。</li>
</ul>
<p>一般三层的B-Tree便可存储2000W条记录，相对于B+树查找次数变少，更合理利用磁盘（物理层面）</p>
<b>不能使用索引和索引失效</b>
<ul>
    <li>使用%模糊匹配时前置%会导致不能使用索引</li>
    <li>索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描。</li>
    <li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引。（会自动类型转换）</li>
    <li>如果mysql估计使用全表扫描要比使用索引快,则不使用索引。</li>
    <li>使用组合索引时没有匹配最左前缀法则</li>
    <li>条件中索引使用大于小于等这样子的范围值,其之后连接条件的索引会失效。</li>
    <li>or大多数情况下很少能利用到索引(条件全命中索引才行)</li>
    <li>对列进行函数转换或计算时会导致无法使用索引</li>
    <li>where条件中判断NULL，会转向全表扫描因为全表扫描更快。</li>
</ul>
<h4>3.数据库优化</h4>
<b>方案</b>
<ul>
    <li>优化现有的MySQL数据库。</li>
    <li>硬件优化，加钱买更好的服务器。</li>
    <li>使用NoSQL/NewSQL等。</li>
</ul>
<b>表优化</b>
<ul>
    <li>字段优先级： 整型 > date,time > emum char > varchar > blob,text</li>
    <li>尽量让字段不为空，空值会额外占用索引空间。</li>
    <li>尽量使用无符号INT而非BIGINT,如果更小的SMALLINT等够用的情况下使用其更好。</li>
    <li>保存时间时尽量使用TIMESTAMP，其次DATETIME，尽量不要使用VARCHAR。</li>
    <li>单表字段不宜过多，20以内为好。</li>
    <li>IP地址等字段尽量使用整形存储。</li>
    <li>精确值，例如金额等使用DECIMAL。</li>
    <li>VARCHAR的长度只分配真正需要的空间。</li>
    <li>可以使用enum代替varchar来保存字符串</li>
    <li>尽量不用TEXT，使用的情况进行分表操作。</li>
</ul>
<b>索引优化</b>
<ul>
    <li>必须要有主键，主键尽量为整型。InnoDB的聚簇索引为主键索引。</li>
    <li>数据值类别少的地方不建议索引，例如男女等。</li>
    <li>去掉不必要的索引，例如组合索引的前提下，又建立了满足最左前缀的索引、并没有使用到的索引等。</li>
    <li>在经常被使用到的字段加索引。WHERE或ORDER BY涉及到的列。</li>
    <li>建立索引的字段越小越好，尽量不为NULL。</li>
</ul>
<b>sql语句优化</b>
<ul>
    <li>尽量使用limit来限限制查询的数量。</li>
    <li>使用连接来代替来代替子查询</li>
    <li>优化语句防止索引失效，上边有。</li>
    <li>在进行条件判断时，应该保证条件前后类型相同。</li>
    <li>尽量再一次查询中获得想要的数据，避免在后台代码中二次判断。</li>
    <li>在明确保证两个表数据不同的情况下使用UNION ALL。</li>
    <li>不建议使用SELECT * (虽然优化了)。</li>
</ul>
<h4>4.其他</h4>
<b>MySQL日志</b>
<ul>
    <li>重做日志(redo log):是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页。</li>
    <li>回滚日志(undo log):用来回滚行记录到某个版本，是逻辑日志，根据每行记录进行记录。</li>
    <li>二进制日志(bin log):用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步；用于数据库的基于时间点的还原。</li>
    <li>错误日志(error log):用于记录MySQL服务进程mysqld在启动/关闭或运行过程中遇到的错误信息。</li>
    <li>一般查询日志(general log):默认是关闭的，记录了所有MySQL数据库请求的信息。无论这些请求是否得到了正确的执行。</li>
    <li>慢查询日志(slow query log):用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。</li>
    <li>中继日志(relay log):从服务器I/O线程将主服务器的二进制日志读取过来记录到从服务器本地文件，然后SQL线程会读取relay-log日志的内容并应用到从服务器，从而使从服务器和主服务器的数据保持一致。</li>
</ul>
<b>三大范式</b>
<ul>
    <li>第一范式：表中的每一列都是不可再分的。</li>
    <li>第二范式：每个非主属性完全函数依赖于键码。每个表必须有且仅有一个数据元素为主关键字(Primary key),其他数据元素与主关键字一一对应。</li>
    <li>第三范式：非主属性不传递函数依赖于键码。所有数据元素不但要能唯一地被主关键字所标识,而且它们之间还必须相互独立,不存在其他的函数关系。</li>
</ul>
<b>锁</b>
<ul>
    <li>InnoDB支持行锁和表锁。只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</li>
    <li>乐观锁：用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。</li>
    <li>悲观锁：悲观锁是由数据库自己实现了的分为共享锁和排他锁。</li>
    <li>共享锁（S锁）：是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改，使用lock in share mode。当一个事务使用S锁时只可对该行进行读操作，其他事务也可对其加S锁（不能加X锁）。
    </li>
    <li>排它锁（X锁）：使用for update。当一个事务使用X锁可对其进行读写操作且其他事务无法在对其加任何锁。</li>
    <li>意向锁（IS和IX）：对其加X锁之前必须先获取IX。对其加S锁之前必须获取IS或IX。两种锁是互相兼容的只是表示加锁实际上并没有加锁。</li>
</ul>
<p>{{ page.date | date_to_string }}</p>